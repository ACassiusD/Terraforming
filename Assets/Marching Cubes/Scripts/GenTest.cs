using UnityEngine;

//Uses compute shaders to generate a 3D raw density map of the terrain and optinally a processed (blurred) density map
public class GenTest : MonoBehaviour
{
	[Header("Generation Parameters")]
    public float terrainBoundarySize = 500; //The bounding box of the terrain measured in unity units. (Imagine a grid boundry where the terrain is generated within)
    public int chunksPerDimension = 10; //The number of chunks in the X,Y,Z (i.e. 10^3=100 chunks total)
    public int numPointsPerAxis = 10; //The number of points we can  sample dentisy values from on each axis of a chunk
    public float isoLevel = 0f;
	public bool useFlatShading;
	public float noiseScale;
	public float noiseHeightMultiplier;
	public bool blurMap;
	public int blurRadius = 3;

	[Header("References")]
	public ComputeShader meshCompute;
	public ComputeShader densityCompute;
	public ComputeShader blurCompute;
	public ComputeShader editCompute;
	public Material material;

    //Small manageable pieces of the terrain with coordinates, center, size, and a GameObject for mesh rendering.
    Chunk[] chunkArray;

    //Buffers
    ComputeBuffer triangleBuffer; //Stores the vertices generated by the Marching Cubes algorithm, an array of VertexData structs. GPU based
    ComputeBuffer triCountBuffer; //Small, efficiently structured Intermediary buffer, Only stores a single integer — the # of elements in triangleBuffer. Serves as bridge for data transfer between GPU and CPU

	//For compute shader output
    [HideInInspector] public RenderTexture rawDensityTexture;
	[HideInInspector] public RenderTexture processedDensityTexture;

	VertexData[] vertexDataArray;

	RenderTexture originalMap;

    //For logging to Debugger.
    int totalVerticesCount;
    int totalTriangleCount;

	//Timers
    System.Diagnostics.Stopwatch timer_fetchVertexData;
    System.Diagnostics.Stopwatch timer_processVertexData;

    void Start()
	{
        InitTextures(); // Create 3D textures to store density values of terrain generated by noise
		CreateBuffers(); // Create buffers to store triangle count and triangle vertices
        CreateChunks(); // Create the chunks that will be used to render the terrain to. These contain coordinates, center, size etc to represent a point in our games world

		var stopWatch = System.Diagnostics.Stopwatch.StartNew(); //For timing how long it takes to generate the terrain
		
		GenerateAllChunks(); //TODO: Finisgh Study this + density compute shader.
		
		Debug.Log("Generation Time: " + stopWatch.ElapsedMilliseconds + " ms");
		ComputeHelper.CreateRenderTexture3D(ref originalMap, processedDensityTexture);
		ComputeHelper.CopyRenderTexture3D(processedDensityTexture, originalMap);
	}

	//Gets the size of the terrain by multiplying the number of chunks by the size of each chunk
	//Create the render textures that represent that terrain
	//Set the textures on the compute shaders to be rendered to
	void InitTextures()
	{
		//Getting the length of a single axis of the bounding box of the terrain
        int terrainBoundingBoxAxisLength = chunksPerDimension * (numPointsPerAxis - 1) + 1;

        //Create 3D textures using this densityGridSize from that single axis size
        //For storing non-visual data density values.
        Create3DTexture(ref rawDensityTexture, terrainBoundingBoxAxisLength, "Raw Density Texture");
		Create3DTexture(ref processedDensityTexture, terrainBoundingBoxAxisLength, "Processed Density Texture");

		if (!blurMap)
		{
			processedDensityTexture = rawDensityTexture;
		}

		// Set textures on compute shaders
		densityCompute.SetTexture(0, "DensityTexture", rawDensityTexture);
		editCompute.SetTexture(0, "EditTexture", rawDensityTexture);
		blurCompute.SetTexture(0, "Source", rawDensityTexture);
		blurCompute.SetTexture(0, "Result", processedDensityTexture);
		meshCompute.SetTexture(0, "DensityTexture", (blurCompute) ? processedDensityTexture : rawDensityTexture);
	}

    /// <summary>
    /// Creates a 3D texture with the specified axis size and name.
    /// </summary>
    /// <param name="texture">The RenderTexture to create or update.</param>
    /// <param name="axisLength">The size of the texture on a single axis.</param>
    /// <param name="name">The name of the texture.</param>
    void Create3DTexture(ref RenderTexture texture, int axisLength, string name)
    {
        //Each point in the 3D texture (which is defined by a coordinate on all three axes) stores a single 32-bit floating-point number
        var format = UnityEngine.Experimental.Rendering.GraphicsFormat.R32_SFloat;

        if (texture == null || !texture.IsCreated() || texture.width != axisLength || texture.height != axisLength || texture.volumeDepth != axisLength || texture.graphicsFormat != format)
        {
            //frees the memory used by the texture
            if (texture != null)
                texture.Release();

            // Set texture height, width, and depthbuffer. Also set the format to float.
            // The depth buffer is used in rendering to handle which objects are in front of others, but it's not relevant for the texture's 3D structure.
            const int numBitsInDepthBuffer = 0;
            texture = new RenderTexture(axisLength, axisLength, numBitsInDepthBuffer);
            texture.graphicsFormat = format;

			// Add third dimension (of x,y,z) to texture and tell unity to treat it as a 3D texture
            texture.volumeDepth = axisLength;
            texture.dimension = UnityEngine.Rendering.TextureDimension.Tex3D;

            // Enable random write access for the texture to allow compute shaders to write data to any location.
            // This is necessary for dynamic updates or modifications by compute shaders.
            texture.enableRandomWrite = true;
            texture.Create();
        }
        // Setting wrap mode to Repeat allows the texture coordinates to exceed the 0-1 range,
        // causing the texture to tile or repeat across the surface it's applied to.
        texture.wrapMode = TextureWrapMode.Repeat;

        // Bilinear for smoother texture sampling, which helps in minimizing artifacts when the texture is scaled or transformed.
        texture.filterMode = FilterMode.Bilinear;

        texture.name = name;
    }

    // Initializes the GPU based ComputeBuffers as well as a CPU Based buffer 
    // The compute shader buffers for allocating memory on the GPU, it's essential to specify exactly how much memory each element in the buffer will require.
    // The GPU needs this information to manage its memory resources effectively.
    // Stride = the size (in bytes) of one element in the array
    void CreateBuffers()
    {
        //-1 because a x,y,z grid with 1 point per axis would not have any voxels
        int numVoxelsPerAxis = numPointsPerAxis - 1;

        //Cubing the number of voxels per axis.
        int totalNumberOfVoxels = numVoxelsPerAxis * numVoxelsPerAxis * numVoxelsPerAxis;

        //Marching Cubes algorithm can generate up to 5 triangles per voxel in the worst-case scenario
        int maxTriangleCount = totalNumberOfVoxels * 5;

        //Each triangle is made up of 3 vertices
        int maxVertexCount = maxTriangleCount * 3;

        //Create GPU buffers
        //Stores the number of triangles generated by the Marching Cubes algorithm, a single integer
        triCountBuffer = new ComputeBuffer(1, sizeof(int), ComputeBufferType.Raw);

        //A larger buffer to store the vertices of the triangles. Its size depends on the maximum number of triangles that can be generate
        triangleBuffer = new ComputeBuffer(maxVertexCount, ComputeHelper.GetStride<VertexData>(), ComputeBufferType.Append);

        //CPU Based Buffer An array to store the vertex data, which is then used for mesh construction.
        vertexDataArray = new VertexData[maxVertexCount];
    }

	// Creates the chunks that will be used to render the terrain
    void CreateChunks()
    {
        chunkArray = new Chunk[chunksPerDimension * chunksPerDimension * chunksPerDimension];

        float chunkSize = (terrainBoundarySize) / chunksPerDimension;
        int i = 0;

        for (int y = 0; y < chunksPerDimension; y++)
        {
            for (int x = 0; x < chunksPerDimension; x++)
            {
                for (int z = 0; z < chunksPerDimension; z++)
                {
                    Vector3Int coord = new Vector3Int(x, y, z);
                    float posX = (-(chunksPerDimension - 1f) / 2 + x) * chunkSize;
                    float posY = (-(chunksPerDimension - 1f) / 2 + y) * chunkSize;
                    float posZ = (-(chunksPerDimension - 1f) / 2 + z) * chunkSize;
                    Vector3 centre = new Vector3(posX, posY, posZ);

                    GameObject meshHolder = new GameObject($"Chunk ({x}, {y}, {z})");
                    meshHolder.transform.parent = transform;
                    meshHolder.layer = gameObject.layer;

                    Chunk chunk = new Chunk(coord, centre, chunkSize, numPointsPerAxis, meshHolder);
                    chunk.SetMaterial(material);
                    chunkArray[i] = chunk;
                    i++;
                }
            }
        }
    }

    //Use density compute shader to generate the density values for each point in the 3D terrain texture
	//Then Loop through each chunk in chunkArray  and generate the mesh and print the timers
    void GenerateAllChunks()
	{
        // Stopwatch timers:
        timer_fetchVertexData = new System.Diagnostics.Stopwatch();
		timer_processVertexData = new System.Diagnostics.Stopwatch();

		// Use compute shader to generate density values
		ComputeDensity();

		//Generate mesh for each chunk
		for (int i = 0; i < chunkArray.Length; i++) {
			GenerateChunk(chunkArray[i]);
		}

        Debug.Log("Total Triangles " + totalTriangleCount);
        Debug.Log("Total Verticies " + totalVerticesCount);
        Debug.Log("Fetch vertex data: " + timer_fetchVertexData.ElapsedMilliseconds + " ms");
		Debug.Log("Process vertex data: " + timer_processVertexData.ElapsedMilliseconds + " ms");
		Debug.Log("Sum: " + (timer_fetchVertexData.ElapsedMilliseconds + timer_processVertexData.ElapsedMilliseconds) + " ms");
	}

	//Set the varaibles for the density compute shader and dispatch it using the helper class to get the raw density map
	//Afterwords if blurMap is true then call ProcessDensityMap() to blur the density map
	void ComputeDensity()
	{
		// Get points (each point is a vector4: xyz = position, w = density)
		int textureSize = rawDensityTexture.width;

		//Set Density ompute shader parameters
		densityCompute.SetInt("textureSize", textureSize);
		densityCompute.SetFloat("planetSize", terrainBoundarySize);
		densityCompute.SetFloat("noiseHeightMultiplier", noiseHeightMultiplier);
		densityCompute.SetFloat("noiseScale", noiseScale);

		ComputeHelper.Dispatch(densityCompute, textureSize, textureSize, textureSize);

		ProcessDensityMap();
	}

	//If blurMap is true, calculate the processed density map by blurring the raw density map
	void ProcessDensityMap()
	{
		if (blurMap)
		{
			int size = rawDensityTexture.width;
			blurCompute.SetInts("brushCentre", 0, 0, 0);
			blurCompute.SetInt("blurRadius", blurRadius);
			blurCompute.SetInt("textureSize", rawDensityTexture.width);
			ComputeHelper.Dispatch(blurCompute, size, size, size);
		}
	}

	// Generate the vertex data for the chunk after setting its coordinates into the mesh compute shader
	// Then creates the mesh using the vertex data
	void GenerateChunk(Chunk chunk)
	{
		int numVoxelsPerAxis = numPointsPerAxis - 1;
		int marchKernel = 0;

		// Set mesh compute shader params and buffers
		meshCompute.SetInt("textureSize", processedDensityTexture.width);
		meshCompute.SetInt("numPointsPerAxis", numPointsPerAxis);
		meshCompute.SetFloat("isoLevel", isoLevel);
		meshCompute.SetFloat("planetSize", terrainBoundarySize);
		triangleBuffer.SetCounterValue(0);
		meshCompute.SetBuffer(marchKernel, "triangles", triangleBuffer);
		Vector3 chunkCoord = (Vector3)chunk.id * (numPointsPerAxis - 1);
		meshCompute.SetVector("chunkCoord", chunkCoord);

		// Dispatch mesh compute shader
		ComputeHelper.Dispatch(meshCompute, numVoxelsPerAxis, numVoxelsPerAxis, numVoxelsPerAxis, marchKernel);

        // Fetch vertex Count from GPU
        // Using an intermediate buffer (triCountBuffer) and a specialized copy operation to efficiently and accurately transfer vertexCountData from the GPU to the CPU
        // Retrieves the count of elements from triangleBuffer and places it into triCountBuffer
        int[] triangleCountData = new int[1];
		triCountBuffer.SetData(triangleCountData);
		ComputeBuffer.CopyCount(triangleBuffer, triCountBuffer, 0);

        // Fetch vertex data from GPU
        // Use the count we got from the GPU to retrieve the vertex data from triangleBuffer (GPU) and place it into vertexDataArray (CPU)
        timer_fetchVertexData.Start();
		triCountBuffer.GetData(triangleCountData);
		int numVertices = triangleCountData[0] * 3;
        triangleBuffer.GetData(vertexDataArray, 0, 0, numVertices);
		timer_fetchVertexData.Stop();

        // Update debug info
        totalVerticesCount += numVertices;
        totalTriangleCount += triangleCountData[0];

        // Create the mesh using the vertex data
        timer_processVertexData.Start();
		chunk.CreateMesh(vertexDataArray, numVertices, useFlatShading); //TODO: understand
		timer_processVertexData.Stop();
	}

	void Update()
	{
		// TODO: move somewhere more sensible
		material.SetTexture("DensityTex", originalMap);
		material.SetFloat("oceanRadius", FindObjectOfType<Water>().radius);
		material.SetFloat("planetBoundsSize", terrainBoundarySize);
	}


	void ReleaseBuffers(){
		ComputeHelper.Release(triangleBuffer, triCountBuffer);
	}

	void OnDestroy()
	{
		ReleaseBuffers();
		foreach (Chunk chunk in chunkArray)
		{
			chunk.Release();
		}
	}


	public void Terraform(Vector3 point, float weight, float radius)
	{
		int editTextureSize = rawDensityTexture.width;
		float editPixelWorldSize = terrainBoundarySize / editTextureSize;
		int editRadius = Mathf.CeilToInt(radius / editPixelWorldSize);
		//Debug.Log(editPixelWorldSize + "  " + editRadius);

		float tx = Mathf.Clamp01((point.x + terrainBoundarySize / 2) / terrainBoundarySize);
		float ty = Mathf.Clamp01((point.y + terrainBoundarySize / 2) / terrainBoundarySize);
		float tz = Mathf.Clamp01((point.z + terrainBoundarySize / 2) / terrainBoundarySize);

		int editX = Mathf.RoundToInt(tx * (editTextureSize - 1));
		int editY = Mathf.RoundToInt(ty * (editTextureSize - 1));
		int editZ = Mathf.RoundToInt(tz * (editTextureSize - 1));

		editCompute.SetFloat("weight", weight);
		editCompute.SetFloat("deltaTime", Time.deltaTime);
		editCompute.SetInts("brushCentre", editX, editY, editZ);
		editCompute.SetInt("brushRadius", editRadius);

		editCompute.SetInt("size", editTextureSize);
		ComputeHelper.Dispatch(editCompute, editTextureSize, editTextureSize, editTextureSize);

		//ProcessDensityMap();
		int size = rawDensityTexture.width;

		if (blurMap)
		{
			blurCompute.SetInt("textureSize", rawDensityTexture.width);
			blurCompute.SetInts("brushCentre", editX - blurRadius - editRadius, editY - blurRadius - editRadius, editZ - blurRadius - editRadius);
			blurCompute.SetInt("blurRadius", blurRadius);
			blurCompute.SetInt("brushRadius", editRadius);
			int k = (editRadius + blurRadius) * 2;
			ComputeHelper.Dispatch(blurCompute, k, k, k);
		}

		//ComputeHelper.CopyRenderTexture3D(originalMap, processedDensityTexture);

		float worldRadius = (editRadius + 1 + ((blurMap) ? blurRadius : 0)) * editPixelWorldSize;
		for (int i = 0; i < chunkArray.Length; i++)
		{
			Chunk chunk = chunkArray[i];
			if (MathUtility.SphereIntersectsBox(point, worldRadius, chunk.centre, Vector3.one * chunk.size))
			{

				chunk.terra = true;
				GenerateChunk(chunk);

			}
		}
	}
}